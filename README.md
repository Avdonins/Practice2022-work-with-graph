# Разработка алгоритма определения существования циклов в ориентированном полном графе и разработка ПО на языке C++ на основе этого алгоритма.

По заданию дан полный граф с N вершинами, имеющий два вида ребер (для удобства будем отмечать их как 0 и 1) такой, что N<sub>i</sub> → N<sub>j</sub> => i > j, т.е. существуют пути только из вершины с меньшим номером в вершину с большим номером. В заданной задаче оптимальным графом будет называться такой граф, в котором между двумя любыми вершинами существует путь только по одному виду ребер.

## Функционал
*	Генерация случайного ориентированного графа с заданным количеством вершин.
*	Вывод графа в консоль.
*	Определение оптимальности графа.

## Решение
1.	Представление графа в виде двух графов, состоящих только из ребер одного вида.
2.	Начальный граф изменяется путем изменения направления ребер одного типа (например, если есть ребро из вершины 1 в вершину 4 типа 1, это ребро удаляется и добавляется ребро из вершины 4 в вершину 1 типа 0).
Для реализации первого подхода графы будут представляться в программе в виде списка смежности. Для второго подхода будет использоваться матрица смежности. В обоих подходах для поиска путей используется поиск в глубину. Выполнение задачи будет сводится к преобразованию изначального графа к циклическому и поиску в нем циклов.

### Первый подход
Изначально можно разделить граф на два подграфа, каждый из которых состоит ребер одного типа. Например, пусть задан граф из 4 вершин:

![image](https://github.com/Avdonins/Practice2022-work-with-graph/assets/81324706/794a5fa7-8c00-4d36-b83d-85c4310fa780)

Тогда после разделения мы получим следующие два подграфа:

![image](https://github.com/Avdonins/Practice2022-work-with-graph/assets/81324706/3398a4f7-57e9-42c5-8370-63ca5d28ca78)

По условию задачи граф будет оптимальным, если в полученных двух графов отсутствуют одинаковые пути. Граф выше является неоптимальным, т.к. в обоих графах есть путь из вершины 1 в вершину 3.
#### Реализация
Функция, определяющая оптимальный ли граф:

```c++
bool is_optimal(vector<vector<int>>& graph1, vector<vector<int>>& graph2) {
  for (int i = 0; i < graph1.size(); i++) {
    for (int j = (i + 1); j < graph1.size(); j++) {
      if (dfs(graph1, i, j) && dfs(graph2, i, j)) {
        return false;
      }
    }
  }
  return true;
}
```
Поиск в глубину, определяющий есть ли путь из вершины start в вершину finish:
```c++
bool dfs(vector<vector<int>>& graph, int start, int finish) {
  if (start == finish) {
    return true;
  } else if (start > finish)
    return false;
  for (int j = 0; j < graph[start].size(); j++) {
    if (dfs(graph, graph[start][j], finish)) {
      return true;
    }
  }
  return false;
}
```
#### Определение сложности
Поскольку в функции is_optimal используется вложенный цикл, сложность этой операции будет O(N2). Алгоритм DFS имеет сложность O(V+E) (где V – количество вершин, E – количество ребер), т.к. для каждой вершины мы оцениваем лишь примыкающие к ней грани. Каждая вершина имеет определенное количество ребер и, в худшем случае, мы обойдем все вершины (O(V)) и исследуем все грани (O(E)). Мы имеем V вершин и E граней, поэтому получаем V+E. Следовательно сложность увеличивается до O(V<sup>2</sup>(V+ E) ≈ O(V<sup>3</sup>).

### Второй подход
Изначально можно изменить направление всех ребер одного типа. Например, используем граф из предыдущего примера:

![image](https://github.com/Avdonins/Practice2022-work-with-graph/assets/81324706/21655a2a-eb49-4233-9ca3-26b346b79474)

Развернем все синие ребра, получим следующий граф:

![image](https://github.com/Avdonins/Practice2022-work-with-graph/assets/81324706/278be680-cd3b-487f-a907-eb2db4663506)

По условию задачи граф будет оптимальным, если в полученном графе не будет циклов. Полученный граф будет неоптимальным, т.к. имеется цикл   1 → 2 → 3 → 1.

#### Реализация
Функция, определяющая оптимальный ли граф:
```c++
bool is_optimal_for_graph_with_all_roads(vector<vector<int>>& graph) {
  vector<bool> used(graph.size());
  for (int i = 0; i < graph.size(); i++) {
    if (dfs_cycle(graph, i, used)) {
      return false;
    }
    used.assign(used.size(), false);
  }
  return true;
}
```
Поиск в глубину, определяющий есть ли цикл в графе для вершины start:
```c++
bool dfs_cycle(vector<vector<int>>& graph, int start, vector<bool>& used) {
  if (used[start]) {
    return true;
  }
  used[start] = true;
  for (int i = 0; i < graph[start].size(); i++) {
    if (graph[start][i] != -1)
      if (dfs_cycle(graph, i, used)) {
        return true;
      }
  }
  used[start] = false;
  return false;
}
```
#### Определение сложности:
Поскольку в функции is_optimal_for_graph_with_all_roads используется цикл, сложность этой операции будет O(N). Алгоритм DFS имеет сложность O(V+E) (где V – количество вершин, E – количество ребер), т.к. для каждой вершины мы оцениваем лишь примыкающие к ней грани. Каждая вершина имеет определенное количество ребер и, в худшем случае, мы обойдем все вершины (O(V)) и исследуем все грани (O(E)). Мы имеем V вершин и E граней, поэтому получаем V+E. Следовательно сложность увеличивается до O(V(V+ E)) ≈ O(V<sup>2</sup>).

## Результаты выполнения программы
![image](https://github.com/Avdonins/Practice2022-work-with-graph/assets/81324706/a910353f-ba35-4a7f-a9ab-55923a8b34e6)
